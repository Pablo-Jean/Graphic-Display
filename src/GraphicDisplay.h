/*
 * GraphicDisplay.h
 *
 *  Created on: Jun 28, 2024
 *      Author: pablo-jean
 */

#ifndef GRAPHICDISPLAY_H_
#define GRAPHICDISPLAY_H_

/*
 * Includes
 */

#include <assert.h>
#include <math.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <stdbool.h>
#include <string.h>

#include "drivers/ssd1306/ssd1306.h"
#include "drivers/st7920/st7920.h"

/*
 * Check if gd_config.h exists, otherwise, we load a 'default' configuration
 *
 * NOTE: Some compilers can`t support this directive, but the following list can support.
 * Clang
 * GCC from 5.X
 * Visual Studio from VS2015 Update 2
 *
 * If your compiler give an error in this line, insert the NO_SUPPORT_FOR_HAS_INCLUDED
 * in the preprocessor of your compiler and you need to create the "gd_config.h" header file
 */
#ifndef NO_SUPPORT_FOR_HAS_INCLUDED
	#if __has_include("gd_config.h")
		#include "gd_config.h"
	#else
		#define GD_INCLUDE_FONT_6x8
		#define GD_INCLUDE_FONT_7x10
		#define GD_INCLUDE_FONT_11x18
		#define GD_INCLUDE_FONT_16x26
		#define GD_INCLUDE_FONT_16x24
		#define GD_INCLUDE_FONT_16x15
	#endif
#else
	#include "gd_config.h"
#endif

/*
 * Macros
 */

/*
 * Enumerates
 */

/**
 * @enum gd_error_e
 * @brief Errors that can be generated by library
 *
 */
typedef enum{
	GD_OK, /**< Operation was performed succefully */
	GD_FAIL/**< Operation was failed, in most cases, is a wrong parameter  */
}gd_error_e;

/**
 * @enum gd_color_e
 * @brief Defines the pixel color of the display we want to write
 *
 */
typedef enum{
	GD_BLACK,/**< it's similar to a blank pixel, turned off */
	GD_WHITE /**< Turns the pixel opaque, or turn it on */
}gd_color_e;

/*
 * Structs
 */

/**
 * @fn fxnGd_mtxLock
 * @brief Locks the mutex to prevent overrun and conflicts over threads in
 * RTOS environments.
 *
 * @pre Call a function where waits and locks the mutex.
 */
typedef void (*fxnGd_mtxLock)(void);

/**
 * @fn fxnGd_mtxUnlock
 * @brief Unlock the mutex after use on threadsafe need operations.
 *
 * @pre Call a function where mutex is freed.
 */
typedef void (*fxnGd_mtxUnlock)(void);

/**
 * @struct gd_driver_t
 * @brief Struct that creates a driver for the display, holding the handle and
 * functions that are private of the display driver. This allows the library to
 * be very flexible and can handles any display.
 *
 */
typedef struct{
	/** @brief Handle of the display. The variable that holds all data of device. */
	void* pHandle;

	/**
	 * @fn fxnSetPixelColor
	 * @brief Sets a value of a pixel on a gived position on the Frame Buffer.
	 * Please, do not directly write on display, just write on a buffer.
	 * @note This function is MANDATORY!
	 *
	 * @param handle 	Pointer to handle of the device
	 * @param x			Position in X-axis
	 * @param y			Position on Y-axis
	 * @param color		Value to write on pixel, 0 to black, 1 to white.
	 * @return			0 to SUCCESS, otherwise on failed.
	 */
	uint8_t (*fxnSetPixelColor)(void* handle, uint32_t x, uint32_t y, uint8_t color);

	/**
	 * @fn fxnFillFrameBuffer
	 * @brief Fills the Frame Buffer of the display device with a provided color.
	 * @note This function is MANDATORY!
	 *
	 * @param handle 	Pointer to handle of the device
	 * @param color	 	Value to write on pixel, 0 to black, 1 to white.
	 * @return		 	0 to SUCCESS, otherwise on failed.
	 */
	uint8_t (*fxnFillFrameBuffer)(void* handle, uint8_t color);

	/**
	 * @fn fxnRefreshDisp.
	 * @brief Refresh the display with the internal Frame Buffer.
	 * This method, improves the performance of the display driver and Graphic Display lib.
	 * @note This function is MANDATORY!
	 *
	 * @param handle	Pointer to handle of the device.
	 * @return			0 to SUCCESS, otherwise if failed.
	 */
	uint8_t (*fxnRefreshDisp)(void* handle);

	/**
	 * @fn fxnSetOn
	 * @brief Turns the display on or off.
	 * @note This function is optional.
	 *
	 * @param handle	Pointer to handle of the device.
	 * @param on		true to turn on display, false to turn off.
	 * @return			0 to SUCCESS, otherwise if failed.
	 */
	uint8_t (*fxnSetOn)(void* handle, bool on);

	/**
	 * @fn fxnSetContrast
	 * @brief Set the contrast of the display, the internal value must be treated with:
	 * 0 to minimal contrast.
	 * 100 to maximum contrast.
	 * @note This function is optional.
	 *
	 * @param handle	Pointer to handle of the display device.
	 * @param value		Value from 0 to 100 to sets the contrast.
	 * @return			0 to SUCCESS, otherwise if failed.
	 */
	uint8_t (*fxnSetContrast)(void* handle, uint8_t value);

}gd_driver_t;

/**
 * @struct gd_font_t
 * @brief Structure to holds Fonts. The default fonts are defined in GraphicDisplay_Fonts.h.
 * You can create your own fonts. A software that creates this fonts must be searched.
 *
 */
typedef struct {
	/**< @brief Font width in pixels */
	const uint8_t width;
	/**< @brief Font height in pixels */
	const uint8_t height;
	/**< @brief Pointer to font data array */
	const uint16_t *const data;
	 /**< @brief Proportional character width in pixels (NULL for monospaced) */
    const uint8_t *const char_width;
}gd_font_t;

/**
 * @struct gd_vertex_t
 * @brief Structure used to support the creation of polylines.
 * In normal use, this is declared as an array, with X and Y points to build lines,
 * between this lines.
 *
 */
typedef struct{
	/** @brief point in X axis */
	uint32_t x;
	/** @brief point in Y axis */
	uint32_t y;
}gd_vertex_t;

/**
 * @struct gd_t
 * @brief Handler of Graphic Display. Each display must need your own handler.
 * Yes, this library supports multiples displays.
 *
 * @pre A good practice is to initialize this handler with all parameters as zero.
 */
typedef struct{
	/** @brief Display height in Lines. Must be the same of display device. */
	uint32_t u32Height;
	/** @brief Display width in columns. Must be the same of display device */
	uint32_t u32Width;

	struct t_fxn{
		/**	@brief mutex lock function pointer.
		 *  @note Developer must to no change this parameters directly.*/
		fxnGd_mtxLock mtxLock;
		/** @brief mutex unlock function pointer.
		 *  @note Developer must to no change this parameters directly.*/
		fxnGd_mtxUnlock mtxUnlock;
	}fxn;

	/** @brief Display driver, that contains the Handler and routines.
	 * @note Developer must to no change this parameters directly.  */
	gd_driver_t *disp;

	struct t_intern{
		/** @brief Size of the Frame Buffer display
		 *  @note Developer must to no change this parameters directly.*/
		uint32_t u32BufferLen;
		/** @brief Current X display position.
		 *  @note Developer must to no change this parameters directly.*/
		uint32_t u32CurrX;
		/** @brief Current Y display position.
		 *  @note Developer must to no change this parameters directly.*/
		uint32_t u32CurrY;
		/** @brief Boolean to save display state
		 *  @note Developer must to no change this parameters directly.*/
		bool bDisplayOn;
		/** @brief Boolean to tell if Graphic Display handler is initialized.
		 *  @note Developer must to no change this parameters directly.*/
		bool bInitialized;
	}_intern; /** @brief Internal variables of gd_t. */
}gd_t;

/**
 * @struct gd_params_t
 * @brief Parameters to initialize the Graphic Display Handler.
 * @note Used only on handler startup.
 */
typedef struct{
	/**
	 * @brief Handle of the display, provide the pointer of this handler.
	 * Example fort ssd1306 display:
	 *
	 * gt_t Gd;
	 * ssd1306_t Ssd1306;
	 *
	 * ... initialize ssd1306 ...
	 *
	 * Gd.DisplayHandle = (void*)&Ssd1306;
	 *
	 * ... provide other parameters ...
	 * ... initialize display Gd ...
	 *
	 * @note Must not be NULL
	 */
	void *DisplayHandle;

	/** @brief Driver for the display. @ref Ext_Drivers.
	 *  @note Must not be NULL.*/
	gd_driver_t *DisplayDriver;

	/** @brief The Heigth of the display, in lines.
	 *  @note Must greater than 0.
	 */
	uint32_t u32Height;

	/** @brief The Width of the display, in columns.
	 *  @note Must greater than 0.
	 */
	uint32_t u32Width;

	/**	@brief mutex lock function pointer.
	 *  @note This parameter is optional.
	 */
	fxnGd_mtxLock mtxLock;

	/**	@brief mutex unlock function pointer.
	 *  @note This parameter is optional.
	 */
	fxnGd_mtxUnlock mtxUnlock;
}gd_params_t;

/*
 * Exterrns
 */

/** @defgroup Ext_Drivers External implemented drivers for displays.
 * 	@brief Drivers for implemented display device drivers.
 * 	Below, we have the devices implemented.
 *
 * 	@{
 */
/** @brief SSD1306 Display Driver pointer. */
extern gd_driver_t* Gd_Driver_SSD1306;
/** @brief ST7920 Display Driver poointer. */
extern gd_driver_t* Gd_Driver_ST7920;
/**
  * @}
  */

/*
 * Publics
 */

/**
 * @fn gd_error_e GD_Init(gd_t*, gd_params_t*)
 * @brief Initializes the Graphic Display module, configured with the parameters
 * provided.
 *
 * @pre 			Initialize the display device driver, and provide the required parameters.
 * @param Gd		Pointer to the Graphic Display handle.
 * @param params	Pointer with the parameters of the Graphic Display.
 * @return			GD_OK if operation is success.
 */
gd_error_e GD_Init(gd_t *Gd, gd_params_t *params);

/**
 * @fn gd_error_e GD_Fill(gd_t*, gd_color_e)
 * @brief Fill the Frame Buffer with the provided color.
 *
 * @pre 			Graphic Display is initialized.
 * @param Gd		Pointer to the Graphic Display handle.
 * @param color		The color to fill the buffer, GD_BLACK to erase, GD_WHITE to turnon all pixels.
 * @return			GD_OK if success.
 */
gd_error_e GD_Fill(gd_t *Gd, gd_color_e color);

/**
 * @fn gd_error_e GD_UpdateScreen(gd_t*)
 * @brief Update and refresh the update screen with the data into Frame Buffer.
 *
 * @pre			Graphic Display is initialized.
 * @param Gd	Pointer to the Graphic Display handle.
 * @return		GD_OK if success.
 */
gd_error_e GD_UpdateScreen(gd_t *Gd);

/**
 * @fn gd_error_e GD_DrawPixel(gd_t*, uint32_t, uint32_t, gd_color_e)
 * @brief Write a color into the desired pixel in the frame buffer.
 *
 * @pre 		Graphic Display is initialized.
 * @param Gd	Pointer to the Graphic Display handle.
 * @param x		X axis of pixel to write.
 * @param y		Y axis of pixel to write.
 * @param color	Color to write on the pixel.
 * @return		GD_OK if success.
 */
gd_error_e GD_DrawPixel(gd_t *Gd,  uint32_t x, uint32_t y, gd_color_e color);

/**
 * @fn gd_error_e GD_WriteChar(gd_t*, char, const gd_font_t*, gd_color_e)
 * @brief Write a character into a Frame Buffer, with the lines with the desired color.
 *
 * @pre 		Graphic Display is initialized.
 * @param Gd	Pointer to the Graphic Display handle.
 * @param ch	Character coded in ASCII.
 * @param Font	Pointer to the Fontset to write.
 * @param color Color of the character.
 * @return		GD_OK if success.
 */
gd_error_e GD_WriteChar(gd_t *Gd,  char ch, const gd_font_t *Font, gd_color_e color);

/**
 * @fn gd_error_e GD_WriteString(gd_t*, char*, const gd_font_t*, gd_color_e)
 * @brief Write a string into frame buffer, with the character lines with the desired color.
 *
 * @pre			Graphic Display is initialized.
 * @param Gd	Pointer to the Graphic Display handle.
 * @param str	Char array, ended with '\0' character.
 * @param Font	Pointer to the Fontset to write.
 * @param color Color of the string.
 * @return		GD_OK if success.
 */
gd_error_e GD_WriteString(gd_t *Gd,  char* str, const gd_font_t *Font, gd_color_e color);

/**
 * @fn gd_error_e GD_SetCursor(gd_t*, uint32_t, uint32_t)
 * @brief Set the cursor to the position X,Y.
 *
 * @pre			Graphic Display is initialized.
 * @param Gd	Pointer to the Graphic Display handle.
 * @param x		X axis position.
 * @param y		Y axis position.
 * @return		GD_OK if success.
 */
gd_error_e GD_SetCursor(gd_t *Gd,  uint32_t x, uint32_t y);

/**
 * @fn gd_error_e GD_Line(gd_t*, uint32_t, uint32_t, uint32_t, uint32_t, gd_color_e)
 * @brief Write a line into the frame buffer between (x1,y1) (x2,y2).
 *
 * @pre			Graphic Display is initialized.
 * @param Gd	Pointer to the Graphic Display handle.
 * @param x1	X axis for the first point.
 * @param y1	Y axis for the first point.
 * @param x2	X axis for the second point.
 * @param y2	Y axis for the second point.
 * @param color	Color of the line.
 * @return		GD_OK if success.
 */
gd_error_e GD_Line(gd_t *Gd,  uint32_t x1, uint32_t y1, uint32_t x2, uint32_t y2, gd_color_e color);

/**
 * @fn gd_error_e GD_DrawArc(gd_t*, uint32_t, uint32_t, uint32_t, uint16_t, uint16_t, gd_color_e)
 * @brief Draw an arc into the frame buffer with center, radius, start angle, and sweep.
 *
 * @pre					Graphic Display is initialized.
 * @param Gd			Pointer to the Graphic Display handle.
 * @param x				X axis of the center of Arc.
 * @param y				Y axis of the center of Arc.
 * @param radius		Radius of the Arc.
 * @param start_angle	Initial angle in degrees.
 * @param sweep			Sweep of the arc.
 * @param color			Color of the arc.
 * @return				GD_OK if success.
 */
gd_error_e GD_DrawArc(gd_t *Gd,  uint32_t x, uint32_t y, uint32_t radius, uint16_t start_angle, uint16_t sweep, gd_color_e color);

/**
 * @fn gd_error_e GD_DrawArcWithRadiusLine(gd_t*, uint32_t, uint32_t, uint32_t, uint16_t, uint16_t, gd_color_e)
 * @brief Draw an arc into frame buffer with lines in the radius line.
 *
 * @pre					Graphic Display is initialized.
 * @param Gd			Pointer to the Graphic Display handle.
 * @param x				X axis of the center of Arc.
 * @param y				Y axis of the center of Arc.
 * @param radius		Radius of the Arc.
 * @param start_angle	Initial angle in degrees.
 * @param sweep			Sweep of the arc.
 * @param color			Color of the arc.
 * @return				GD_OK if success.
 */
gd_error_e GD_DrawArcWithRadiusLine(gd_t *Gd, uint32_t x, uint32_t y, uint32_t radius, uint16_t start_angle, uint16_t sweep, gd_color_e color);


/**
 * @fn gd_error_e GD_DrawCircle(gd_t*, uint32_t, uint32_t, uint32_t, gd_color_e)
 * @brief Draw a complete circle with defined radius.
 *
 * @pre				Graphic Display is initialized.
 * @param Gd		Pointer to the Graphic Display handle.
 * @param par_x		X axis of the center of circle.
 * @param par_y 	Y axis of the center of circle.
 * @param par_r		Radius of the circle.
 * @param color		Color of the circle.
 * @return			GD_OK if success.
 */
gd_error_e GD_DrawCircle(gd_t *Gd, uint32_t par_x, uint32_t par_y, uint32_t par_r, gd_color_e color);


/**
 * @fn gd_error_e GD_FillCircle(gd_t*, uint32_t, uint32_t, uint32_t, gd_color_e)
 * @brief Draw a circle filled with the provided color.
 *
 * @pre					Graphic Display is initialized.
 * @param Gd			Pointer to the Graphic Display handle.
 * @param par_x			X axis of the center of circle.
 * @param par_y			Y axis of the center of circle.
 * @param par_r			Radius of the circle.
 * @param par_color		Color of the circle.
 * @return				GD_OK if success.
 */
gd_error_e GD_FillCircle(gd_t *Gd, uint32_t par_x,uint32_t par_y,uint32_t par_r,gd_color_e par_color);

/**
 * @fn gd_error_e GD_Polyline(gd_t*, gd_vertex_t*, uint16_t, gd_color_e)
 * @brief
 *
 * @pre
 * @post
 * @param Gd
 * @param par_vertex
 * @param par_size
 * @param color
 * @return
 */
gd_error_e GD_Polyline(gd_t *Gd, gd_vertex_t *par_vertex, uint16_t par_size, gd_color_e color);

/**
 * @fn gd_error_e GD_DrawRectangle(gd_t*, uint32_t, uint32_t, uint32_t, uint32_t, gd_color_e)
 * @brief
 *
 * @pre
 * @post
 * @param Gd
 * @param x1
 * @param y1
 * @param x2
 * @param y2
 * @param color
 * @return
 */
gd_error_e GD_DrawRectangle(gd_t *Gd, uint32_t x1, uint32_t y1, uint32_t x2, uint32_t y2, gd_color_e color);

/**
 * @fn gd_error_e GD_FillRectangle(gd_t*, uint32_t, uint32_t, uint32_t, uint32_t, gd_error_e)
 * @brief
 *
 * @pre
 * @post
 * @param Gd
 * @param x1
 * @param y1
 * @param x2
 * @param y2
 * @param color
 * @return
 */
gd_error_e GD_FillRectangle(gd_t *Gd, uint32_t x1, uint32_t y1, uint32_t x2, uint32_t y2, gd_error_e color);

/**
 * @fn gd_error_e GD_DrawBitmap(gd_t*, uint32_t, uint32_t, const unsigned char*, uint32_t, uint32_t, gd_color_e)
 * @brief
 *
 * @pre
 * @post
 * @param Gd
 * @param x
 * @param y
 * @param bitmap
 * @param w
 * @param h
 * @param color
 * @return
 */
gd_error_e GD_DrawBitmap(gd_t *Gd, uint32_t x, uint32_t y, const unsigned char* bitmap, uint32_t w, uint32_t h, gd_color_e color);

/**
 * @brief Sets the contrast of the display.
 * @param[in] value contrast to set.
 * @note Contrast increases as the value increases.
 * @note RESET = 7Fh.
 */
gd_error_e GD_SetContrast(gd_t *Gd, const uint8_t value);

/**
 * @brief Set Display ON/OFF.
 * @param[in] on 0 for OFF, any for ON.
 */
gd_error_e GD_SetDisplayOn(gd_t *Gd, bool on);

/**
 * @brief Reads DisplayOn state.
 * @return  0: OFF.
 *          1: ON.
 */
bool GD_GetDisplayOn(gd_t *Gd);

// Low-level procedures
gd_error_e GD_Reset(gd_t *Gd);
gd_error_e GD_WriteCommand(gd_t *Gd, uint8_t byte);
gd_error_e GD_WriteData(gd_t *Gd, uint8_t* buffer, size_t buff_size);


#endif /* GRAPHICDISPLAY_H_ */
