/**
 * @file 		GraphicDisplay.h
 * @author 		Pablo Jean Rozario
 * @brief 		Main header file of Graphic Display Library, here we have the middle layer
 * 				of the library. Where we works on drawing elements (texts, bitmaps and
 * 				geometric forms). In drivers folder we have the low layer, composed by
 * 				display controller drivers.
 * 				The drivers are independet of the Graphic Display files, you can use them in
 * 				more advanced libraries, like [LVGL](https://github.com/lvgl/lvgl).
 * 				This library is created to be flexible and scalable, allowing the engineer
 * 				to use any amount of display, of any type.
 * 
 * @note		This library only works with monochrome displays.
 * @version 	1.0.0
 * @date 		2024-06-28
 * 
 * @copyright Copyright (c) 2024
 * 
 */

#ifndef GRAPHICDISPLAY_H_
#define GRAPHICDISPLAY_H_


/*
 * Includes
 */

#include <assert.h>
#include <math.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <stdbool.h>
#include <string.h>

#include "drivers/ssd1306/ssd1306.h"
#include "drivers/st7920/st7920.h"

/*
 * Check if gd_config.h exists, otherwise, we load a 'default' configuration
 *
 * NOTE: Some compilers can`t support this directive, but the following list can support.
 * Clang
 * GCC from 5.X
 * Visual Studio from VS2015 Update 2
 *
 * If your compiler give an error in this line, insert the NO_SUPPORT_FOR_HAS_INCLUDED
 * in the preprocessor of your compiler and you need to create the "gd_config.h" header file
 */
#ifndef NO_SUPPORT_FOR_HAS_INCLUDED
	#if __has_include("gd_config.h")
		#include "gd_config.h"
	#else
		#define GD_INCLUDE_FONT_6x8
		#define GD_INCLUDE_FONT_7x10
		#define GD_INCLUDE_FONT_11x18
		#define GD_INCLUDE_FONT_16x26
		#define GD_INCLUDE_FONT_16x24
		#define GD_INCLUDE_FONT_16x15
	#endif
#else
	#include "gd_config.h"
#endif

/*
 * Macros
 */

/*
 * Enumerates
 */

/**
 * @enum gd_error_e
 * @brief Errors that can be generated by library
 *
 */
typedef enum{
	GD_OK, /**< Operation was performed succefully */
	GD_FAIL/**< Operation was failed, in most cases, is a wrong parameter  */
}gd_error_e;

/**
 * @enum gd_color_e
 * @brief Defines the pixel color of the display we want to write
 *
 */
typedef enum{
	GD_BLACK,/**< it's similar to a blank pixel, turned off */
	GD_WHITE /**< Turns the pixel opaque, or turn it on */
}gd_color_e;

/*
 * Structs
 */

/**
 * @brief Locks the mutex to prevent overrun and conflicts over threads in
 * RTOS environments.
 *
 * @pre Call a function where waits and locks the mutex.
 */
typedef void (*fxnGd_mtxLock)(void);

/**
 * @brief Unlock the mutex after use on threadsafe need operations.
 *
 * @pre Call a function where mutex is freed.
 */
typedef void (*fxnGd_mtxUnlock)(void);

/** @defgroup Gd_Drivers Driver Definition and Creation
 * 	@brief Driver definition for the Graphic Display library, this driver is the main reason
 *  why we can use any display with this library, you just need to create functions that are
 *  compatible with this structure.
 * 
 *  ## >> Step by Step:
 *  ### 1. Create a folder inside drivers with the name of driver device.
 * Create a folder to place the source code of your driver, in this way, we can keep a clean and nice
 * repository.
 * 
 *  ### 2. Create the .h and .c file for you device.
 * 	Suppose we create a driver for a fictional ss9090 device, we will create **ss9090.h** and **ss9090.c files**.
 * 
 * ### 3. In header file, create the handle structure 
 * The handle structure is used to keep data of a display, with this approach, we can have many displays
 * our project requires, and this displays can be the same or different.
 * 
 * ~~~~~{.c} 
 * typedef struct{
 * 	// define the parameters that you need and functions to handle the device
 * }ss9090_t;
 * ~~~~~
 * 
 * The most common parameters are the:
 *  - Height and Width of the display;
 *  - Frame Buffer pointer;
 *  - Communication Functions (For SPI, we have the Chip Select and SPI transfer, For I2C, commonly has only
 *  the write function).
 * 
 * Other parameters, that's are optional, but recommended, if a function to mutex lock and unlock (useful for
 * RTOS environments that need threadsafe), and Delay Milliseconds routine, some times, delay is mandatory in
 * initialization.
 * 
 * Remember, the driver must be not glued with any chipset, this library must be compatible with any microcontroller.
 * 
 * ### 4. Create routines
 * Here, we have the MANDATORY FUNCTIONS, must be implemented by you, following the fictional ss9090, 
 * we have this prototypes:
 * 
 * ~~~~~{.c} 
 * uint8_t SS9090_Init(ss9090_t *ss9090, ss9090_params_t *params);
 * uint8_t SS9090_Refresh(ss9090_t *ss9090);
 * uint8_t SS9090_WritePixel(ss9090_t *ss9090, uint32_t x, uint32_t y, bool color);
 * uint8_t SS9090_Fill(ss9090_t *ss9090, uint8_t color);
 * ~~~~~
 * 
 * - **Q: I can modify functions names?**
 * - A: Yes, you can!
 * 
 * - **Q: I can modify parameters of the functions?**
 * - A: No, you have the use the same parameters, in same order, and, parameters size, must be compatible.
 * 
 * - **Q: Must be compatible to use without Graphic Display?**
 * - A: Yes
 * 
 * ### 4.5 Test
 * At this point, test your library, check if initialization works, if the pixels are written into correct
 * position, response speed, and everything else.
 * 
 * After you test your driver, you can move on to the next steps.
 * 
 * ### 5. Add include into GraphicDisplay.h
 * Go to *GraphicDisplay.h* and include the new driver 
 * 
 * ~~~~~{.c} 
 * #include "driver/ss9090/ss9090.h"
 * ~~~~~
 * 
 *  ### 6. Create extern pointer to driver
 *  Before the Public functions, you will see a piece of code with the Driver externs.
 *  
 *  Here, you need to create the extern pointer to the driver, this will help developer to insert
 * the driver on code. For SS9090, we write as follows the extern:
 * 
 * ~~~~~{.c} 
 * extern gd_driver_t* Gd_Driver_SS9090;
 * ~~~~~
 * 
 * ### 7. Instance the Driver Variable
 * Go to *GraphicDisplay.c*, in the beginning, you will see the structs containing the drivers, now, creates
 * the instance attributing the function calls to the struct, and the pointer. Here, we use pointers, because they
 * are more fast to pass as a parameters.
 * For our fictional SS9090 driver, we have something similar to this:
 * 
 * ~~~~~{.c}
 * // Diver for SS9090 
 * gd_driver_t _Gd_Driver_SS9090Attr = {
 * 		.pHandle = NULL,
 * 		.fxnSetPixelColor = _SET_PIXEL_COLOR_TYPECAST		SS9090_WritePixel,
 * 		.fxnFillFrameBuffer = _FILL_FRAME_BUFFER_TYPEFCAST 	SS9090_Fill,
 * 		.fxnRefreshDisp = _REFRESH_DISP_TYPECAST 			SS9090_Refresh,
 * 		.fxnSetOn = _SET_ON_TYPECASTAT 						NULL,
 * 		.fxnSetContrast = _SET_CONTRAST_TYPECAST			NULL
 * };
 * gd_driver_t *Gd_Driver_SS9090 = &_Gd_Driver_SS9090Attr;
 * ~~~~~
 * 
 * ### 8. Done
 * Your library is implemented, so, almost, all you need to do is test your implementation ans check if everything works
 * as expected.
 * 
 * Any doubts, feel free to open issues into the repository.
 * 
 * Engineer: Pablo Jean Rozario.
 * 
 * @{
 *
 */
/**
 * @struct gd_driver_t
 * @brief Struct that creates a driver for the display, holding the handle and
 * functions that are private of the display driver. This allows the library to
 * be very flexible and can handles any display.
 *
 */
typedef struct{
	/** @brief Handle of the display. The variable that holds all data of device. */
	void* pHandle;

	/**
	 * @brief Sets a value of a pixel on a gived position on the Frame Buffer.
	 * Please, do not directly write on display, just write on a buffer.
	 * @note This function is MANDATORY!
	 *
	 * @param handle 	Pointer to handle of the device
	 * @param x			Position in X-axis
	 * @param y			Position on Y-axis
	 * @param color		Value to write on pixel, 0 to black, 1 to white.
	 * @return			0 to SUCCESS, otherwise on failed.
	 */
	uint8_t (*fxnSetPixelColor)(void* handle, uint32_t x, uint32_t y, uint8_t color);

	/**
	 * @brief Fills the Frame Buffer of the display device with a provided color.
	 * @note This function is MANDATORY!
	 *
	 * @param handle 	Pointer to handle of the device
	 * @param color	 	Value to write on pixel, 0 to black, 1 to white.
	 * @return		 	0 to SUCCESS, otherwise on failed.
	 */
	uint8_t (*fxnFillFrameBuffer)(void* handle, uint8_t color);

	/**
	 * @brief Refresh the display with the internal Frame Buffer.
	 * This method, improves the performance of the display driver and Graphic Display lib.
	 * @note This function is MANDATORY!
	 *
	 * @param handle	Pointer to handle of the device.
	 * @return			0 to SUCCESS, otherwise if failed.
	 */
	uint8_t (*fxnRefreshDisp)(void* handle);

	/**
	 * @brief Turns the display on or off.
	 * @note This function is optional.
	 *
	 * @param handle	Pointer to handle of the device.
	 * @param on		true to turn on display, false to turn off.
	 * @return			0 to SUCCESS, otherwise if failed.
	 */
	uint8_t (*fxnSetOn)(void* handle, bool on);

	/**
	 * @brief Set the contrast of the display, the internal value must be treated with:
	 * 0 to minimal contrast.
	 * 100 to maximum contrast.
	 * @note This function is optional.
	 *
	 * @param handle	Pointer to handle of the display device.
	 * @param value		Value from 0 to 100 to sets the contrast.
	 * @return			0 to SUCCESS, otherwise if failed.
	 */
	uint8_t (*fxnSetContrast)(void* handle, uint8_t value);

}gd_driver_t;

 /**
 * 	@}
 */

/**
 * @struct gd_font_t
 * @brief Structure to holds Fonts. The default fonts are defined in GraphicDisplay_Fonts.h.
 * You can create your own fonts. A software that creates this fonts must be searched.
 *
 */
typedef struct {
	/**< @brief Font width in pixels */
	const uint8_t width;
	/**< @brief Font height in pixels */
	const uint8_t height;
	/**< @brief Pointer to font data array */
	const uint16_t *const data;
	 /**< @brief Proportional character width in pixels (NULL for monospaced) */
    const uint8_t *const char_width;
}gd_font_t;

/**
 * @struct gd_vertex_t
 * @brief Structure used to support the creation of polylines.
 * In normal use, this is declared as an array, with X and Y points to build lines,
 * between this lines.
 *
 */
typedef struct{
	/** @brief point in X axis */
	uint32_t x;
	/** @brief point in Y axis */
	uint32_t y;
}gd_vertex_t;

/**
 * @struct gd_t
 * @brief Handler of Graphic Display. Each display must need your own handler.
 * Yes, this library supports multiples displays.
 *
 * @pre A good practice is to initialize this handler with all parameters as zero.
 */
typedef struct{
	/** @brief Display height in Lines. Must be the same of display device. */
	uint32_t u32Height;
	/** @brief Display width in columns. Must be the same of display device */
	uint32_t u32Width;

	struct t_fxn{
		/**	@brief mutex lock function pointer.
		 *  @note Developer must to no change this parameters directly.*/
		fxnGd_mtxLock mtxLock;
		/** @brief mutex unlock function pointer.
		 *  @note Developer must to no change this parameters directly.*/
		fxnGd_mtxUnlock mtxUnlock;
	}fxn;

	/** @brief Display driver, that contains the Handler and routines.
	 * @note Developer must to no change this parameters directly.  */
	gd_driver_t *disp;

	struct t_intern{
		/** @brief Size of the Frame Buffer display
		 *  @note Developer must to no change this parameters directly.*/
		uint32_t u32BufferLen;
		/** @brief Current X display position.
		 *  @note Developer must to no change this parameters directly.*/
		uint32_t u32CurrX;
		/** @brief Current Y display position.
		 *  @note Developer must to no change this parameters directly.*/
		uint32_t u32CurrY;
		/** @brief Boolean to save display state
		 *  @note Developer must to no change this parameters directly.*/
		bool bDisplayOn;
		/** @brief Boolean to tell if Graphic Display handler is initialized.
		 *  @note Developer must to no change this parameters directly.*/
		bool bInitialized;
	}_intern; /** @brief Internal variables of gd_t. */
}gd_t;

/**
 * @struct gd_params_t
 * @brief Parameters to initialize the Graphic Display Handler.
 * @note Used only on handler startup.
 */
typedef struct{
	/**
	 * @brief Handle of the display, provide the pointer of this handler.
	 * Example fort ssd1306 display:
	 *
	 * gt_t Gd;
	 * ssd1306_t Ssd1306;
	 *
	 * ... initialize ssd1306 ...
	 *
	 * Gd.DisplayHandle = (void*)&Ssd1306;
	 *
	 * ... provide other parameters ...
	 * ... initialize display Gd ...
	 *
	 * @note Must not be NULL
	 */
	void *DisplayHandle;

	/** @brief Driver for the display. @ref Ext_Drivers.
	 *  @note Must not be NULL.*/
	gd_driver_t *DisplayDriver;

	/** @brief The Heigth of the display, in lines.
	 *  @note Must greater than 0.
	 */
	uint32_t u32Height;

	/** @brief The Width of the display, in columns.
	 *  @note Must greater than 0.
	 */
	uint32_t u32Width;

	/**	@brief mutex lock function pointer.
	 *  @note This parameter is optional.
	 */
	fxnGd_mtxLock mtxLock;

	/**	@brief mutex unlock function pointer.
	 *  @note This parameter is optional.
	 */
	fxnGd_mtxUnlock mtxUnlock;
}gd_params_t;

/*
 * Externs
 */

/** @defgroup Ext_Drivers External Drivers Already Implemented
 * 	@brief Drivers for implemented display device drivers.
 * 	Below, we have the devices implemented.
 *
 * 	@{
 */
/** @brief SSD1306 Display Driver pointer. */
extern gd_driver_t* Gd_Driver_SSD1306;
/** @brief ST7920 Display Driver poointer. */
extern gd_driver_t* Gd_Driver_ST7920;
/**
  * @}
  */

/*
 * Publics
 */

/** @defgroup Gd_Function Graphic Display Functions
 * 	@brief Graphic Display functions, used during Graphic Display Operation.
 *
 * 	@{
 */
/**
 * @brief Initializes the Graphic Display module, configured with the parameters
 * provided.
 *
 * @pre 			Initialize the display device driver, and provide the required parameters.
 * @param Gd		Pointer to the Graphic Display handle.
 * @param params	Pointer with the parameters of the Graphic Display.
 * @return			GD_OK if operation is success.
 */
gd_error_e GD_Init(gd_t *Gd, gd_params_t *params);

/**
 * @brief Fill the Frame Buffer with the provided color.
 *
 * @pre 			Graphic Display is initialized.
 * @param Gd		Pointer to the Graphic Display handle.
 * @param color		The color to fill the buffer, GD_BLACK to erase, GD_WHITE to turnon all pixels.
 * @return			GD_OK if success.
 */
gd_error_e GD_Fill(gd_t *Gd, gd_color_e color);

/**
 * @brief Update and refresh the update screen with the data into Frame Buffer.
 *
 * @pre			Graphic Display is initialized.
 * @param Gd	Pointer to the Graphic Display handle.
 * @return		GD_OK if success.
 */
gd_error_e GD_UpdateScreen(gd_t *Gd);

/**
 * @brief Write a color into the desired pixel in the frame buffer.
 *
 * @pre 		Graphic Display is initialized.
 * @param Gd	Pointer to the Graphic Display handle.
 * @param x		X axis of pixel to write.
 * @param y		Y axis of pixel to write.
 * @param color	Color to write on the pixel.
 * @return		GD_OK if success.
 */
gd_error_e GD_DrawPixel(gd_t *Gd,  uint32_t x, uint32_t y, gd_color_e color);

/**
 * @brief Write a character into a Frame Buffer, with the lines with the desired color.
 *
 * @pre 		Graphic Display is initialized.
 * @param Gd	Pointer to the Graphic Display handle.
 * @param ch	Character coded in ASCII.
 * @param Font	Pointer to the Fontset to write.
 * @param color Color of the character.
 * @return		GD_OK if success.
 */
gd_error_e GD_WriteChar(gd_t *Gd,  char ch, const gd_font_t *Font, gd_color_e color);

/**
 * @brief Write a string into frame buffer, with the character lines with the desired color.
 *
 * @pre			Graphic Display is initialized.
 * @param Gd	Pointer to the Graphic Display handle.
 * @param str	Char array, ended with '\0' character.
 * @param Font	Pointer to the Fontset to write.
 * @param color Color of the string.
 * @return		GD_OK if success.
 */
gd_error_e GD_WriteString(gd_t *Gd,  char* str, const gd_font_t *Font, gd_color_e color);

/**
 * @brief Set the cursor to the position X,Y.
 *
 * @pre			Graphic Display is initialized.
 * @param Gd	Pointer to the Graphic Display handle.
 * @param x		X axis position.
 * @param y		Y axis position.
 * @return		GD_OK if success.
 */
gd_error_e GD_SetCursor(gd_t *Gd,  uint32_t x, uint32_t y);

/**
 * @brief Write a line into the frame buffer between (x1,y1) (x2,y2).
 *
 * @pre			Graphic Display is initialized.
 * @param Gd	Pointer to the Graphic Display handle.
 * @param x1	X axis for the first point.
 * @param y1	Y axis for the first point.
 * @param x2	X axis for the second point.
 * @param y2	Y axis for the second point.
 * @param color	Color of the line.
 * @return		GD_OK if success.
 */
gd_error_e GD_Line(gd_t *Gd,  uint32_t x1, uint32_t y1, uint32_t x2, uint32_t y2, gd_color_e color);

/**
 * @brief Draw an arc into the frame buffer with center, radius, start angle, and sweep.
 *
 * @pre					Graphic Display is initialized.
 * @param Gd			Pointer to the Graphic Display handle.
 * @param x				X axis of the center of Arc.
 * @param y				Y axis of the center of Arc.
 * @param radius		Radius of the Arc.
 * @param start_angle	Initial angle in degrees.
 * @param sweep			Sweep of the arc.
 * @param color			Color of the arc.
 * @return				GD_OK if success.
 */
gd_error_e GD_DrawArc(gd_t *Gd,  uint32_t x, uint32_t y, uint32_t radius, uint16_t start_angle, uint16_t sweep, gd_color_e color);

/**
 * @brief Draw an arc into frame buffer with lines in the radius line.
 *
 * @pre					Graphic Display is initialized.
 * @param Gd			Pointer to the Graphic Display handle.
 * @param x				X axis of the center of Arc.
 * @param y				Y axis of the center of Arc.
 * @param radius		Radius of the Arc.
 * @param start_angle	Initial angle in degrees.
 * @param sweep			Sweep of the arc.
 * @param color			Color of the arc.
 * @return				GD_OK if success.
 */
gd_error_e GD_DrawArcWithRadiusLine(gd_t *Gd, uint32_t x, uint32_t y, uint32_t radius, uint16_t start_angle, uint16_t sweep, gd_color_e color);


/**
 * @brief Draw a complete circle with defined radius.
 *
 * @pre				Graphic Display is initialized.
 * @param Gd		Pointer to the Graphic Display handle.
 * @param par_x		X axis of the center of circle.
 * @param par_y 	Y axis of the center of circle.
 * @param par_r		Radius of the circle.
 * @param color		Color of the circle.
 * @return			GD_OK if success.
 */
gd_error_e GD_DrawCircle(gd_t *Gd, uint32_t par_x, uint32_t par_y, uint32_t par_r, gd_color_e color);


/**
 * @brief Draw a circle filled with the provided color.
 *
 * @pre					Graphic Display is initialized.
 * @param Gd			Pointer to the Graphic Display handle.
 * @param par_x			X axis of the center of circle.
 * @param par_y			Y axis of the center of circle.
 * @param par_r			Radius of the circle.
 * @param par_color		Color of the circle.
 * @return				GD_OK if success.
 */
gd_error_e GD_FillCircle(gd_t *Gd, uint32_t par_x,uint32_t par_y,uint32_t par_r,gd_color_e par_color);

/**
 * @brief Draw a polyline, composed by staigth lines connecting the points given by
 * vertex array.
 *
 * @pre					Graphic Display is initialized.
 * @param Gd			Pointer to the Graphic Display handle.
 * @param par_vertex	Vertex array, with (x, y) points, where the lines will be 
 * 						connected
 * @param par_size		The number of points in **par_vertex**.
 * @param color			Color of the polyline.
 * @return				GD_OK if success.
 */
gd_error_e GD_Polyline(gd_t *Gd, gd_vertex_t *par_vertex, uint16_t par_size, gd_color_e color);

/**
 * @brief Draw a Rectangle between the position (x1,y1) and (x2,y2). The rectangle is not filled,
 * just four lines of a thickness of 1px.
 * 
 *
 * @pre					Graphic Display is initialized.
 * @param Gd			Pointer to the Graphic Display handle.
 * @param x1			X axis of first point of rectangle.	
 * @param y1			Y axis of first point of rectangle.
 * @param x2			X axis of second point of rectangle.	
 * @param y2			Y axis of first second of rectangle.
 * @param color			Color of the rectangle borders.
 * @return				GD_OK if success.
 */
gd_error_e GD_DrawRectangle(gd_t *Gd, uint32_t x1, uint32_t y1, uint32_t x2, uint32_t y2, gd_color_e color);

/**
 * @brief Draw a filled rectangle between the pointes (x1,y1) and (x2,y2).
 *
 * @pre					Graphic Display is initialized.
 * @param Gd			Pointer to the Graphic Display handle.
 * @param x1			X axis of first point of rectangle.	
 * @param y1			Y axis of first point of rectangle.
 * @param x2			X axis of second point of rectangle.	
 * @param y2			Y axis of first second of rectangle.
 * @param color			Color of the entire rectangle.
 * @return				GD_OK if success.
 */
gd_error_e GD_FillRectangle(gd_t *Gd, uint32_t x1, uint32_t y1, uint32_t x2, uint32_t y2, gd_error_e color);

/**
 * @brief Draw a bitmap into the Frame Buffer. The bitmap is an array with the pixels on/off.
 * @note You can use the [Open LCD Assistant](https://github.com/faytor/open_lcd_assistant) tool,
 * I have choose this tool because are compatible with any OS.
 *  
 * @pre					Graphic Display is initialized.
 * @param Gd			Pointer to the Graphic Display handle.
 * @param x				Start X axis of bitmap.
 * @param y				Start Y axis of bitmap.
 * @param bitmap		Bitmap array containing the image.
 * @param w				The Width of the bitmap. This parameter must be the real size of bitmap,
 * 						we do not support image resize, yet.
 * @param h				The Height of the bitmap. This parameter must be the real size of bitmap,
 * 						we do not support image resize, yet.
 * @param color			The 'color' of the image. In practice, if parameter was @link GD_BLACK @endlink, 
 * 						this will invert the bitmap color, if was @link GD_WHITE @endlink, the original 
 * 						color is keeped.
 * @return				GD_OK is success.
 */
gd_error_e GD_DrawBitmap(gd_t *Gd, uint32_t x, uint32_t y, const unsigned char* bitmap, uint32_t w, uint32_t h, gd_color_e color);

/**
 * @brief Set the contrast of the display, if are supported. If display doesn't have this
 * routine, nothing will happens.
 * 
 * @pre					Graphic Display is initialized.
 * @param Gd			Pointer to the Graphic Display handle.
 * @param value 		Value of contrast, from 0 to 100.
 * @return  			GD_OK if success.
 */
gd_error_e GD_SetContrast(gd_t *Gd, const uint8_t value);

/**
 * @brief Set display On or Off, if the display implements this routine.
 * 
 * @pre					Graphic Display is initialized.
 * @param Gd 			Pointer to the Graphic Display handle.
 * @param on 			Set to \c true to turn on, of \c to false.
 * @return 				GD_OK if success. 
 */
gd_error_e GD_SetDisplayOn(gd_t *Gd, bool on);

/**
 * @brief Gets the display On/Off state.
 * 
 * @pre					Graphic Display is initialized.
 * @param Gd 			Pointer to the Graphic Display handle.
 * @return 				\c true if the display was online, \c false if not.
 */
bool GD_GetDisplayOn(gd_t *Gd);

/**
  * @}
  */

#endif /* GRAPHICDISPLAY_H_ */
