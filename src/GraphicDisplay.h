/*
 * GraphicDisplay.h
 *
 *  Created on: Jun 28, 2024
 *      Author: pablo-jean
 */

#ifndef GRAPHICDISPLAY_H_
#define GRAPHICDISPLAY_H_

/*
 * Includes
 */

#include <assert.h>
#include <math.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <stdbool.h>
#include <string.h>

#include "drivers/ssd1306/ssd1306.h"
#include "drivers/st7920/st7920.h"

/*
 * Check if gd_config.h exists, otherwise, we load a 'default' configuration
 *
 * NOTE: Some compilers can`t support this directive, but the following list can support.
 * Clang
 * GCC from 5.X
 * Visual Studio from VS2015 Update 2
 *
 * If your compiler give an error in this line, insert the NO_SUPPORT_FOR_HAS_INCLUDED
 * in the preprocessor of your compiler and you need to create the "gd_config.h" header file
 */
#ifndef NO_SUPPORT_FOR_HAS_INCLUDED
	#if __has_include("gd_config.h")
		#include "gd_config.h"
	#else
		#define GD_INCLUDE_FONT_6x8
		#define GD_INCLUDE_FONT_7x10
		#define GD_INCLUDE_FONT_11x18
		#define GD_INCLUDE_FONT_16x26
		#define GD_INCLUDE_FONT_16x24
		#define GD_INCLUDE_FONT_16x15
	#endif
#else
	#include "gd_config.h"
#endif

/*
 * Macros
 */

/*
 * Enumerates
 */

/**
 * @enum gd_error_e
 * @brief Errors that can be generated by library
 *
 */
typedef enum{
	GD_OK, /**< Operation was performed succefully */
	GD_FAIL/**< Operation was failed, in most cases, is a wrong parameter  */
}gd_error_e;

/**
 * @enum gd_color_e
 * @brief Defines the pixel color of the display we want to write
 *
 */
typedef enum{
	GD_BLACK,/**< it's similar to a blank pixel, turned off */
	GD_WHITE /**< Turns the pixel opaque, or turn it on */
}gd_color_e;

/*
 * Structs
 */

/**
 * @fn fxnGd_mtxLock
 * @brief Locks the mutex to prevent overrun and conflicts over threads in
 * RTOS environments.
 *
 * @pre Call a function where waits and locks the mutex.
 */
typedef void (*fxnGd_mtxLock)(void);

/**
 * @fn fxnGd_mtxUnlock
 * @brief Unlock the mutex after use on threadsafe need operations.
 *
 * @pre Call a function where mutex is freed.
 */
typedef void (*fxnGd_mtxUnlock)(void);

/** @defgroup Gd_Drivers Driver Definition and Creation
 * 	@brief Driver definition for the Graphic Display library, this driver is the main reason
 *  why we can use any display with this library, you just need to create functions that are
 *  compatible with this structure.
 * 
 *  ## >> Step by Step:
 *  ### 1. Create a folder inside drivers with the name of driver device.
 * Create a folder to place the source code of your driver, in this way, we can keep a clean and nice
 * repository.
 * 
 *  ### 2. Create the .h and .c file for you device.
 * 	Suppose we create a driver for a fictional ss9090 device, we will create **ss9090.h** and **ss9090.c files**.
 * 
 * ### 3. In header file, create the handle structure 
 * The handle structure is used to keep data of a display, with this approach, we can have many displays
 * our project requires, and this displays can be the same or different.
 * 
 * ~~~~~{.c} 
 * typedef struct{
 * 	// define the parameters that you need and functions to handle the device
 * }ss9090_t;
 * ~~~~~
 * 
 * The most common parameters are the:
 *  - Height and Width of the display;
 *  - Frame Buffer pointer;
 *  - Communication Functions (For SPI, we have the Chip Select and SPI transfer, For I2C, commonly has only
 *  the write function).
 * 
 * Other parameters, that's are optional, but recommended, if a function to mutex lock and unlock (useful for
 * RTOS environments that need threadsafe), and Delay Milliseconds routine, some times, delay is mandatory in
 * initialization.
 * 
 * Remember, the driver must be not glued with any chipset, this library must be compatible with any microcontroller.
 * 
 * ### 4. Create routines
 * Here, we have the MANDATORY FUNCTIONS, must be implemented by you, following the fictional ss9090, 
 * we have this prototypes:
 * 
 * ~~~~~{.c} 
 * uint8_t SS9090_Init(ss9090_t *ss9090, ss9090_params_t *params);
 * uint8_t SS9090_Refresh(ss9090_t *ss9090);
 * uint8_t SS9090_WritePixel(ss9090_t *ss9090, uint32_t x, uint32_t y, bool color);
 * uint8_t SS9090_Fill(ss9090_t *ss9090, uint8_t color);
 * ~~~~~
 * 
 * - **Q: I can modify functions names?**
 * - A: Yes, you can!
 * 
 * - **Q: I can modify parameters of the functions?**
 * - A: No, you have the use the same parameters, in same order, and, parameters size, must be compatible.
 * 
 * - **Q: Must be compatible to use without Graphic Display?**
 * - A: Yes
 * 
 * ### 4.5 Test
 * At this point, test your library, check if initialization works, if the pixels are written into correct
 * position, response speed, and everything else.
 * 
 * After you test your driver, you can move on to the next steps.
 * 
 * ### 5. Add include into GraphicDisplay.h
 * Go to *GraphicDisplay.h* and include the new driver 
 * 
 * ~~~~~{.c} 
 * #include "driver/ss9090/ss9090.h"
 * ~~~~~
 * 
 *  ### 6. Create extern pointer to driver
 *  Before the Public functions, you will see a piece of code with the Driver externs.
 *  
 *  Here, you need to create the extern pointer to the driver, this will help developer to insert
 * the driver on code. For SS9090, we write as follows the extern:
 * 
 * ~~~~~{.c} 
 * extern gd_driver_t* Gd_Driver_SS9090;
 * ~~~~~
 * 
 * ### 7. Instance the Driver Variable
 * Go to *GraphicDisplay.c*, in the beginning, you will see the structs containing the drivers, now, creates
 * the instance attributing the function calls to the struct, and the pointer. Here, we use pointers, because they
 * are more fast to pass as a parameters.
 * For our fictional SS9090 driver, we have something similar to this:
 * 
 * ~~~~~{.c}
 * // Diver for SS9090 
 * gd_driver_t _Gd_Driver_SS9090Attr = {
 * 		.pHandle = NULL,
 * 		.fxnSetPixelColor = _SET_PIXEL_COLOR_TYPECAST		SS9090_WritePixel,
 * 		.fxnFillFrameBuffer = _FILL_FRAME_BUFFER_TYPEFCAST 	SS9090_Fill,
 * 		.fxnRefreshDisp = _REFRESH_DISP_TYPECAST 			SS9090_Refresh,
 * 		.fxnSetOn = _SET_ON_TYPECASTAT 						NULL,
 * 		.fxnSetContrast = _SET_CONTRAST_TYPECAST			NULL
 * };
 * gd_driver_t *Gd_Driver_SS9090 = &_Gd_Driver_SS9090Attr;
 * ~~~~~
 * 
 * ### 8. Done
 * Your library is implemented, so, almost, all you need to do is test your implementation ans check if everything works
 * as expected.
 * 
 * Any doubts, feel free to open issues into the repository.
 * 
 * Engineer: Pablo Jean Rozario.
 * 
 * @{
 *
 */
/**
 * @struct gd_driver_t
 * @brief Struct that creates a driver for the display, holding the handle and
 * functions that are private of the display driver. This allows the library to
 * be very flexible and can handles any display.
 *
 */
typedef struct{
	/** @brief Handle of the display. The variable that holds all data of device. */
	void* pHandle;

	/**
	 * @fn fxnSetPixelColor
	 * @brief Sets a value of a pixel on a gived position on the Frame Buffer.
	 * Please, do not directly write on display, just write on a buffer.
	 * @note This function is MANDATORY!
	 *
	 * @param handle 	Pointer to handle of the device
	 * @param x			Position in X-axis
	 * @param y			Position on Y-axis
	 * @param color		Value to write on pixel, 0 to black, 1 to white.
	 * @return			0 to SUCCESS, otherwise on failed.
	 */
	uint8_t (*fxnSetPixelColor)(void* handle, uint32_t x, uint32_t y, uint8_t color);

	/**
	 * @fn fxnFillFrameBuffer
	 * @brief Fills the Frame Buffer of the display device with a provided color.
	 * @note This function is MANDATORY!
	 *
	 * @param handle 	Pointer to handle of the device
	 * @param color	 	Value to write on pixel, 0 to black, 1 to white.
	 * @return		 	0 to SUCCESS, otherwise on failed.
	 */
	uint8_t (*fxnFillFrameBuffer)(void* handle, uint8_t color);

	/**
	 * @fn fxnRefreshDisp.
	 * @brief Refresh the display with the internal Frame Buffer.
	 * This method, improves the performance of the display driver and Graphic Display lib.
	 * @note This function is MANDATORY!
	 *
	 * @param handle	Pointer to handle of the device.
	 * @return			0 to SUCCESS, otherwise if failed.
	 */
	uint8_t (*fxnRefreshDisp)(void* handle);

	/**
	 * @fn fxnSetOn
	 * @brief Turns the display on or off.
	 * @note This function is optional.
	 *
	 * @param handle	Pointer to handle of the device.
	 * @param on		true to turn on display, false to turn off.
	 * @return			0 to SUCCESS, otherwise if failed.
	 */
	uint8_t (*fxnSetOn)(void* handle, bool on);

	/**
	 * @fn fxnSetContrast
	 * @brief Set the contrast of the display, the internal value must be treated with:
	 * 0 to minimal contrast.
	 * 100 to maximum contrast.
	 * @note This function is optional.
	 *
	 * @param handle	Pointer to handle of the display device.
	 * @param value		Value from 0 to 100 to sets the contrast.
	 * @return			0 to SUCCESS, otherwise if failed.
	 */
	uint8_t (*fxnSetContrast)(void* handle, uint8_t value);

}gd_driver_t;

 /**
 * 	@}
 */

/**
 * @struct gd_font_t
 * @brief Structure to holds Fonts. The default fonts are defined in GraphicDisplay_Fonts.h.
 * You can create your own fonts. A software that creates this fonts must be searched.
 *
 */
typedef struct {
	/**< @brief Font width in pixels */
	const uint8_t width;
	/**< @brief Font height in pixels */
	const uint8_t height;
	/**< @brief Pointer to font data array */
	const uint16_t *const data;
	 /**< @brief Proportional character width in pixels (NULL for monospaced) */
    const uint8_t *const char_width;
}gd_font_t;

/**
 * @struct gd_vertex_t
 * @brief Structure used to support the creation of polylines.
 * In normal use, this is declared as an array, with X and Y points to build lines,
 * between this lines.
 *
 */
typedef struct{
	/** @brief point in X axis */
	uint32_t x;
	/** @brief point in Y axis */
	uint32_t y;
}gd_vertex_t;

/**
 * @struct gd_t
 * @brief Handler of Graphic Display. Each display must need your own handler.
 * Yes, this library supports multiples displays.
 *
 * @pre A good practice is to initialize this handler with all parameters as zero.
 */
typedef struct{
	/** @brief Display height in Lines. Must be the same of display device. */
	uint32_t u32Height;
	/** @brief Display width in columns. Must be the same of display device */
	uint32_t u32Width;

	struct t_fxn{
		/**	@brief mutex lock function pointer.
		 *  @note Developer must to no change this parameters directly.*/
		fxnGd_mtxLock mtxLock;
		/** @brief mutex unlock function pointer.
		 *  @note Developer must to no change this parameters directly.*/
		fxnGd_mtxUnlock mtxUnlock;
	}fxn;

	/** @brief Display driver, that contains the Handler and routines.
	 * @note Developer must to no change this parameters directly.  */
	gd_driver_t *disp;

	struct t_intern{
		/** @brief Size of the Frame Buffer display
		 *  @note Developer must to no change this parameters directly.*/
		uint32_t u32BufferLen;
		/** @brief Current X display position.
		 *  @note Developer must to no change this parameters directly.*/
		uint32_t u32CurrX;
		/** @brief Current Y display position.
		 *  @note Developer must to no change this parameters directly.*/
		uint32_t u32CurrY;
		/** @brief Boolean to save display state
		 *  @note Developer must to no change this parameters directly.*/
		bool bDisplayOn;
		/** @brief Boolean to tell if Graphic Display handler is initialized.
		 *  @note Developer must to no change this parameters directly.*/
		bool bInitialized;
	}_intern; /** @brief Internal variables of gd_t. */
}gd_t;

/**
 * @struct gd_params_t
 * @brief Parameters to initialize the Graphic Display Handler.
 * @note Used only on handler startup.
 */
typedef struct{
	/**
	 * @brief Handle of the display, provide the pointer of this handler.
	 * Example fort ssd1306 display:
	 *
	 * gt_t Gd;
	 * ssd1306_t Ssd1306;
	 *
	 * ... initialize ssd1306 ...
	 *
	 * Gd.DisplayHandle = (void*)&Ssd1306;
	 *
	 * ... provide other parameters ...
	 * ... initialize display Gd ...
	 *
	 * @note Must not be NULL
	 */
	void *DisplayHandle;

	/** @brief Driver for the display. @ref Ext_Drivers.
	 *  @note Must not be NULL.*/
	gd_driver_t *DisplayDriver;

	/** @brief The Heigth of the display, in lines.
	 *  @note Must greater than 0.
	 */
	uint32_t u32Height;

	/** @brief The Width of the display, in columns.
	 *  @note Must greater than 0.
	 */
	uint32_t u32Width;

	/**	@brief mutex lock function pointer.
	 *  @note This parameter is optional.
	 */
	fxnGd_mtxLock mtxLock;

	/**	@brief mutex unlock function pointer.
	 *  @note This parameter is optional.
	 */
	fxnGd_mtxUnlock mtxUnlock;
}gd_params_t;

/*
 * Externs
 */

/** @defgroup Ext_Drivers External Drivers Already Implemented
 * 	@brief Drivers for implemented display device drivers.
 * 	Below, we have the devices implemented.
 *
 * 	@{
 */
/** @brief SSD1306 Display Driver pointer. */
extern gd_driver_t* Gd_Driver_SSD1306;
/** @brief ST7920 Display Driver poointer. */
extern gd_driver_t* Gd_Driver_ST7920;
/**
  * @}
  */

/*
 * Publics
 */

/** @defgroup Gd_Function Graphic Display Functions
 * 	@brief Graphic Display functions, used during Graphic Display Operation.
 *
 * 	@{
 */
/**
 * @fn gd_error_e GD_Init(gd_t*, gd_params_t*)
 * @brief Initializes the Graphic Display module, configured with the parameters
 * provided.
 *
 * @pre 			Initialize the display device driver, and provide the required parameters.
 * @param Gd		Pointer to the Graphic Display handle.
 * @param params	Pointer with the parameters of the Graphic Display.
 * @return			GD_OK if operation is success.
 */
gd_error_e GD_Init(gd_t *Gd, gd_params_t *params);

/**
 * @fn gd_error_e GD_Fill(gd_t*, gd_color_e)
 * @brief Fill the Frame Buffer with the provided color.
 *
 * @pre 			Graphic Display is initialized.
 * @param Gd		Pointer to the Graphic Display handle.
 * @param color		The color to fill the buffer, GD_BLACK to erase, GD_WHITE to turnon all pixels.
 * @return			GD_OK if success.
 */
gd_error_e GD_Fill(gd_t *Gd, gd_color_e color);

/**
 * @fn gd_error_e GD_UpdateScreen(gd_t*)
 * @brief Update and refresh the update screen with the data into Frame Buffer.
 *
 * @pre			Graphic Display is initialized.
 * @param Gd	Pointer to the Graphic Display handle.
 * @return		GD_OK if success.
 */
gd_error_e GD_UpdateScreen(gd_t *Gd);

/**
 * @fn gd_error_e GD_DrawPixel(gd_t*, uint32_t, uint32_t, gd_color_e)
 * @brief Write a color into the desired pixel in the frame buffer.
 *
 * @pre 		Graphic Display is initialized.
 * @param Gd	Pointer to the Graphic Display handle.
 * @param x		X axis of pixel to write.
 * @param y		Y axis of pixel to write.
 * @param color	Color to write on the pixel.
 * @return		GD_OK if success.
 */
gd_error_e GD_DrawPixel(gd_t *Gd,  uint32_t x, uint32_t y, gd_color_e color);

/**
 * @fn gd_error_e GD_WriteChar(gd_t*, char, const gd_font_t*, gd_color_e)
 * @brief Write a character into a Frame Buffer, with the lines with the desired color.
 *
 * @pre 		Graphic Display is initialized.
 * @param Gd	Pointer to the Graphic Display handle.
 * @param ch	Character coded in ASCII.
 * @param Font	Pointer to the Fontset to write.
 * @param color Color of the character.
 * @return		GD_OK if success.
 */
gd_error_e GD_WriteChar(gd_t *Gd,  char ch, const gd_font_t *Font, gd_color_e color);

/**
 * @fn gd_error_e GD_WriteString(gd_t*, char*, const gd_font_t*, gd_color_e)
 * @brief Write a string into frame buffer, with the character lines with the desired color.
 *
 * @pre			Graphic Display is initialized.
 * @param Gd	Pointer to the Graphic Display handle.
 * @param str	Char array, ended with '\0' character.
 * @param Font	Pointer to the Fontset to write.
 * @param color Color of the string.
 * @return		GD_OK if success.
 */
gd_error_e GD_WriteString(gd_t *Gd,  char* str, const gd_font_t *Font, gd_color_e color);

/**
 * @fn gd_error_e GD_SetCursor(gd_t*, uint32_t, uint32_t)
 * @brief Set the cursor to the position X,Y.
 *
 * @pre			Graphic Display is initialized.
 * @param Gd	Pointer to the Graphic Display handle.
 * @param x		X axis position.
 * @param y		Y axis position.
 * @return		GD_OK if success.
 */
gd_error_e GD_SetCursor(gd_t *Gd,  uint32_t x, uint32_t y);

/**
 * @fn gd_error_e GD_Line(gd_t*, uint32_t, uint32_t, uint32_t, uint32_t, gd_color_e)
 * @brief Write a line into the frame buffer between (x1,y1) (x2,y2).
 *
 * @pre			Graphic Display is initialized.
 * @param Gd	Pointer to the Graphic Display handle.
 * @param x1	X axis for the first point.
 * @param y1	Y axis for the first point.
 * @param x2	X axis for the second point.
 * @param y2	Y axis for the second point.
 * @param color	Color of the line.
 * @return		GD_OK if success.
 */
gd_error_e GD_Line(gd_t *Gd,  uint32_t x1, uint32_t y1, uint32_t x2, uint32_t y2, gd_color_e color);

/**
 * @fn gd_error_e GD_DrawArc(gd_t*, uint32_t, uint32_t, uint32_t, uint16_t, uint16_t, gd_color_e)
 * @brief Draw an arc into the frame buffer with center, radius, start angle, and sweep.
 *
 * @pre					Graphic Display is initialized.
 * @param Gd			Pointer to the Graphic Display handle.
 * @param x				X axis of the center of Arc.
 * @param y				Y axis of the center of Arc.
 * @param radius		Radius of the Arc.
 * @param start_angle	Initial angle in degrees.
 * @param sweep			Sweep of the arc.
 * @param color			Color of the arc.
 * @return				GD_OK if success.
 */
gd_error_e GD_DrawArc(gd_t *Gd,  uint32_t x, uint32_t y, uint32_t radius, uint16_t start_angle, uint16_t sweep, gd_color_e color);

/**
 * @fn gd_error_e GD_DrawArcWithRadiusLine(gd_t*, uint32_t, uint32_t, uint32_t, uint16_t, uint16_t, gd_color_e)
 * @brief Draw an arc into frame buffer with lines in the radius line.
 *
 * @pre					Graphic Display is initialized.
 * @param Gd			Pointer to the Graphic Display handle.
 * @param x				X axis of the center of Arc.
 * @param y				Y axis of the center of Arc.
 * @param radius		Radius of the Arc.
 * @param start_angle	Initial angle in degrees.
 * @param sweep			Sweep of the arc.
 * @param color			Color of the arc.
 * @return				GD_OK if success.
 */
gd_error_e GD_DrawArcWithRadiusLine(gd_t *Gd, uint32_t x, uint32_t y, uint32_t radius, uint16_t start_angle, uint16_t sweep, gd_color_e color);


/**
 * @fn gd_error_e GD_DrawCircle(gd_t*, uint32_t, uint32_t, uint32_t, gd_color_e)
 * @brief Draw a complete circle with defined radius.
 *
 * @pre				Graphic Display is initialized.
 * @param Gd		Pointer to the Graphic Display handle.
 * @param par_x		X axis of the center of circle.
 * @param par_y 	Y axis of the center of circle.
 * @param par_r		Radius of the circle.
 * @param color		Color of the circle.
 * @return			GD_OK if success.
 */
gd_error_e GD_DrawCircle(gd_t *Gd, uint32_t par_x, uint32_t par_y, uint32_t par_r, gd_color_e color);


/**
 * @fn gd_error_e GD_FillCircle(gd_t*, uint32_t, uint32_t, uint32_t, gd_color_e)
 * @brief Draw a circle filled with the provided color.
 *
 * @pre					Graphic Display is initialized.
 * @param Gd			Pointer to the Graphic Display handle.
 * @param par_x			X axis of the center of circle.
 * @param par_y			Y axis of the center of circle.
 * @param par_r			Radius of the circle.
 * @param par_color		Color of the circle.
 * @return				GD_OK if success.
 */
gd_error_e GD_FillCircle(gd_t *Gd, uint32_t par_x,uint32_t par_y,uint32_t par_r,gd_color_e par_color);

/**
 * @fn gd_error_e GD_Polyline(gd_t*, gd_vertex_t*, uint16_t, gd_color_e)
 * @brief
 *
 * @pre
 * @post
 * @param Gd
 * @param par_vertex
 * @param par_size
 * @param color
 * @return
 */
gd_error_e GD_Polyline(gd_t *Gd, gd_vertex_t *par_vertex, uint16_t par_size, gd_color_e color);

/**
 * @fn gd_error_e GD_DrawRectangle(gd_t*, uint32_t, uint32_t, uint32_t, uint32_t, gd_color_e)
 * @brief
 *
 * @pre
 * @post
 * @param Gd
 * @param x1
 * @param y1
 * @param x2
 * @param y2
 * @param color
 * @return
 */
gd_error_e GD_DrawRectangle(gd_t *Gd, uint32_t x1, uint32_t y1, uint32_t x2, uint32_t y2, gd_color_e color);

/**
 * @fn gd_error_e GD_FillRectangle(gd_t*, uint32_t, uint32_t, uint32_t, uint32_t, gd_error_e)
 * @brief
 *
 * @pre
 * @post
 * @param Gd
 * @param x1
 * @param y1
 * @param x2
 * @param y2
 * @param color
 * @return
 */
gd_error_e GD_FillRectangle(gd_t *Gd, uint32_t x1, uint32_t y1, uint32_t x2, uint32_t y2, gd_error_e color);

/**
 * @fn gd_error_e GD_DrawBitmap(gd_t*, uint32_t, uint32_t, const unsigned char*, uint32_t, uint32_t, gd_color_e)
 * @brief
 *
 * @pre
 * @post
 * @param Gd
 * @param x
 * @param y
 * @param bitmap
 * @param w
 * @param h
 * @param color
 * @return
 */
gd_error_e GD_DrawBitmap(gd_t *Gd, uint32_t x, uint32_t y, const unsigned char* bitmap, uint32_t w, uint32_t h, gd_color_e color);

/**
 * @brief Sets the contrast of the display.
 * @param[in] value contrast to set.
 * @note Contrast increases as the value increases.
 * @note RESET = 7Fh.
 */
gd_error_e GD_SetContrast(gd_t *Gd, const uint8_t value);

/**
 * @brief Set Display ON/OFF.
 * @param[in] on 0 for OFF, any for ON.
 */
gd_error_e GD_SetDisplayOn(gd_t *Gd, bool on);

/**
 * @brief Reads DisplayOn state.
 * @return  0: OFF.
 *          1: ON.
 */
bool GD_GetDisplayOn(gd_t *Gd);

// Low-level procedures
gd_error_e GD_Reset(gd_t *Gd);
gd_error_e GD_WriteCommand(gd_t *Gd, uint8_t byte);
gd_error_e GD_WriteData(gd_t *Gd, uint8_t* buffer, size_t buff_size);

/**
  * @}
  */

#endif /* GRAPHICDISPLAY_H_ */
